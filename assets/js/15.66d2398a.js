(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{292:function(e,n,t){"use strict";t.r(n);var l=t(4),o=Object(l.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Stevens在文章中一共比较了五种IO Model：")]),e._v(" "),t("ul",[t("li",[e._v("blocking IO 阻塞 I/O")]),e._v(" "),t("li",[e._v("nonblocking IO 非阻塞 I/O")]),e._v(" "),t("li",[e._v("IO multiplexing I/O 的多路复用（select 和 poll）")]),e._v(" "),t("li",[e._v("signal driven IO 信号驱动的 I/O（SIGIO）")]),e._v(" "),t("li",[e._v("asynchronous IO 异步 I/O（POSIX 的 aio_functions）")])]),e._v(" "),t("h2",{attrs:{id:"blocking-io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blocking-io"}},[e._v("#")]),e._v(" blocking IO")]),e._v(" "),t("p",[e._v("在默认情况下Linux中的Socket都是使用的阻塞IO，\n当其被进程调用，kernel就会开始准备接收数据，在接受完数据前，kernel会一直等待这个数据的到达，而当前进程就会阻塞，直到数据接受完成，会将数据从kernelk拷贝到用户内存，然后kernel返回结果。\n此种IO在Java是支持的，就是传统的Socket")]),e._v(" "),t("h2",{attrs:{id:"non-blocking-io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#non-blocking-io"}},[e._v("#")]),e._v(" non-blocking IO")]),e._v(" "),t("p",[e._v("Linux中可以通过设置Socket使其变为non-blocking，\n当一个进程对其发出一个请求，如若数据还没准备好，它不会马上阻塞让你傻等，会返回一个没准备好的信息，然后再发请求，这样循环到kernel中的数据准备好，并且又接收到了请求，那么它马上就将数据拷贝到了用户内存，然后返回。\n在Java1.4中，此种IO在NIO包中得到了支持")]),e._v(" "),t("h2",{attrs:{id:"io-multiplexing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io-multiplexing"}},[e._v("#")]),e._v(" IO multiplexing")]),e._v(" "),t("p",[e._v("平时说的select,poll,epoll就是指的这个，也有叫事件驱动IO（event driven IO），它的好处就是单个进程可以处理多个网络IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有Socket，当某个Socket有数据到达了，就通知用户进程。\n当调用select，整个进程开始阻塞，不是被Socket IO阻塞，而是被select阻塞，\nkernel会监视所有select负责的Socket，当任何一个Socket中的数据准备好了，select就会返回。这个时候用户进程再调用读操作，将数据从kernel拷贝到用户进程。它的优势在于可以同时处理多个请求，不过它开销更大，所以如果不是连接数很高的情况，它或许还不如多线程+阻塞IO。\n在实际运用中，多路复用和非阻塞是标配，阻塞后的操作就谈不上复用了，程序就卡在那里。\n在Java的NIO包中的Selector可以实现这个IO，一般也是搭配非阻塞IO使用。")]),e._v(" "),t("h2",{attrs:{id:"asynchronous-i-o"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asynchronous-i-o"}},[e._v("#")]),e._v(" Asynchronous I/O")]),e._v(" "),t("p",[e._v("异步 I/O 模型的发展技术是： select -> poll -> epoll -> aio -> libevent -> libuv。\n当用户进程发起请求，完全不会阻塞，就可以做其他事去了。当kernel接收到一个asynchronous read，它会立刻返回，所以用户进程不会有任何阻塞。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。\n在Java中NIO包里也含有AIO的实现")]),e._v(" "),t("h2",{attrs:{id:"结语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),t("p",[e._v("前三种IO全是同步IO，Nio会搭配多路复用给人一种伪异步的感觉，实际上它还是同步的，虽然nio大部分时间都不会阻塞，但是它任然要求进程时刻的检查数据是否准备好，当数据准备好，这个时候就要主动将数据拷贝到内存，这个时候就是阻塞的。\naio则完全不管，等一切完成，收个信号知道完成了。")])])}),[],!1,null,null,null);n.default=o.exports}}]);